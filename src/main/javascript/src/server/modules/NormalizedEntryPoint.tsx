import * as React from "react";
import * as ReactDOMServer from "react-dom/server";
import Promise from "bluebird";
import {applyMiddleware, createStore, Store} from 'redux'
import {Provider} from "react-redux";
import thunkMiddleware from "redux-thunk"
import { createLogger } from "redux-logger"
import {Helmet, HelmetData} from "react-helmet";
import Container from "server/components/container/Container";
import Html from 'server/components/html/Html';
import { NormalizedHttpRequest, NormalizedHttpResponse } from 'server/modules/NormalizedHttp';
import NormalizedResponseBuilder from "server/modules/NormalizedResponseBuilder";
import {root as rootReducer, RootState} from "shared/state/RootState";
import {beginHttpRequest} from "shared/state/http/server/request/HttpRequestActions";
import {getRoute} from "shared/modules/routing/Routes";
import {isProduction} from "shared/modules/Environment";
import {ServerError} from "shared/components/error/ServerError";
import {logErrorToBackend} from "shared/modules/Errors";
import {ReactElement} from "react";
import {cookieRegistry} from "shared/modules/CookieRegistry";
import {IncompleteHttpResponse} from "shared/state/http/server/response/HttpResponseState";

export default class NormalizedEntryPoint {
  sendResponse(request: NormalizedHttpRequest, callback: (response: NormalizedHttpResponse) => void) {
    this.renderPage(request).then(callback);
  }

  renderPage(request: NormalizedHttpRequest): Promise<NormalizedHttpResponse> {
    console.log(`${request.method} ${request.urlWithoutHost}`); // Basic request logging, for both PROD and DEV.

    const store = this.initReduxStore(request);

    // Fetch state (if required).
    const route = getRoute(request.path);
    return route.fetchState(store.getState, store.dispatch).then(() => {

      // Perform side effects (if required).
      return route.onArrive(store.getState, store.dispatch).then((redirectUrl) => {
        if (typeof redirectUrl === "string") {
          // Redirect.
          const httpResponseState  = this.getHttpResponse(store.getState()); // headers, cookies, etc.
          const responseBuilder    = new NormalizedResponseBuilder(httpResponseState, request.isSSL);
          responseBuilder.withRedirect(redirectUrl);
          return responseBuilder.response;

        } else {
          // Render (standard component).
          const routerContext      = {};
          const containerComponent = <Provider store={store}><Container request={request} routerContext={routerContext} /></Provider>;
          return this.returnInnerHtml(containerComponent, store, request, false);
        }
      });
    })
    .catch(e => {
      // Render (error component).
      const errorMessage = logErrorToBackend(e);
      console.error(`500 Response Occurred:\n${errorMessage}`);
      return this.returnInnerHtml(<ServerError />, store, request, true);
    });
  }

  returnInnerHtml(innerComponent: ReactElement<any>, store: Store<RootState>, request: NormalizedHttpRequest, isServerError: boolean): NormalizedHttpResponse {
    // Render.
    const errorInnerHtml    = ReactDOMServer.renderToString(innerComponent);

    // Extract data generated by components (required for finishing the request).
    const helmetData        = Helmet.renderStatic(); // page title, etc.
    const state             = store.getState();
    const httpResponseState = this.getHttpResponse(state);

    if (isServerError) { this.setServerErrorHeaders(httpResponseState); }

    const responseBuilder   = new NormalizedResponseBuilder(httpResponseState, request.isSSL);
    const clientState       = this.trimStateForClient(state);
    const responseBody      = this.applyOuterHtmlTemplate(errorInnerHtml, helmetData, clientState, !isServerError);
    responseBuilder.withBody(responseBody);

    return responseBuilder.response;
  }

  getHttpResponse(state: RootState): IncompleteHttpResponse {
    // Important: do not mutate the redux store! Some objects (like initial values) are shared across user sessions.
    // The assumption is that ALL OBJECTS in redux are immutable.
    return {...state.http.server.response};
  }

  setServerErrorHeaders(response: IncompleteHttpResponse): void {
    // Delete session on error. Prevents the user from being locked-out of the site if
    // there's an issue with their session token that causes errors on all pages.
    response.statusCode = 500;
    response.cookies    = {};
    response.cookies[cookieRegistry.sessionJwt.name] = {
      value: null,
      maxAge: 0
    };
  }

  initReduxStore(request: NormalizedHttpRequest): Store<RootState> {
    let reduxMiddleware;
    if (isProduction) {
      reduxMiddleware        = applyMiddleware(thunkMiddleware);
    }
    else {
      const requestId        = this.getShortTermRequestId();
      const loggerMiddleware = this.createReduxLogger(requestId);
      reduxMiddleware        = applyMiddleware(thunkMiddleware, loggerMiddleware);
    }

    const store              = createStore(rootReducer, reduxMiddleware);
    const initialAction      = beginHttpRequest(request);
    store.dispatch(initialAction);

    return store;
  }

  trimStateForClient(state: RootState): RootState {
    const clientState = {...state};

    // 'http' contains potentially sensitive (and also irrelevant) data.
    delete clientState.http;

    // 'form' doesn't get reused by redux-form (so isn't necessary to keep it).
    delete clientState.form;

    return clientState;
  }

  applyOuterHtmlTemplate(containerHtml: string, helmetData: HelmetData, clientState: RootState, enableBrowserJS: boolean): string {
    const placeholder   = 'ROOT_COMPONENT';
    const header        = "<!DOCTYPE html>";
    const htmlComponent = <Html placeholder={placeholder}
                                helmet={helmetData}
                                clientState={clientState}
                                enableBrowserJS={enableBrowserJS} />;
    const htmlReact     = ReactDOMServer.renderToString(htmlComponent);
    const htmlPlain     = htmlReact.replace(/ data-react[^ >]+/g, '');

    // Add IE10 conditional comments (we don't support IE under version 10).
    const htmlClosingBracket   = htmlPlain.indexOf(">") + 1;
    const htmlOpenTag          = htmlPlain.substr(0, htmlClosingBracket);
    const htmlAfterOpenTag     = htmlPlain.substr(htmlClosingBracket);
    const htmlOpenTagWithCheck = `<!--[if lt IE 10]><html class="lt_ie10"><![endif]--><!--[if gte IE 10]><!-->${htmlOpenTag}<!--<![endif]-->`;
    const htmlWithBrowserCheck = htmlOpenTagWithCheck + htmlAfterOpenTag;

    return header + htmlWithBrowserCheck.replace(placeholder, containerHtml)
  }

  // Not intended to be unique in the long-term -- just for short-term log viewing only. We favour easily
  // readable IDs here, as it's for viewing purposes, rather than unique identification in a DB. If we want
  // something better, then perhaps we should create a HEX code and also send this back down through the
  // infrastructure via the X-REQUEST-ID HTTP header.
  getShortTermRequestId() {
    return this.getRandomInt(10000, 99999);
  }

  getRandomInt(min: number, max: number) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
  }

  createReduxLogger(requestId: number) {
    const titleFormatter = (action: any, _time?: string, took?: number) => `—— log start (req #${requestId}) ——\n${action.type} completed in ${took.toFixed(2)}ms`;
    return (createLogger as any)({
      timestamp: false,
      duration: true,
      titleFormatter: titleFormatter,
      colors: {
        title: false,
        prevState: false,
        action: false,
        nextState: false,
        error: false
      }
    });
  }

  getElementInnerText(element: string): string {
    const start = element.indexOf(">") + 1;
    return element.substring(start, element.indexOf("<", start));
  }
}
